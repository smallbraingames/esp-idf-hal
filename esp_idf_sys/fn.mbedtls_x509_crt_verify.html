<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="\brief          Verify a chain of certificates."><title>mbedtls_x509_crt_verify in esp_idf_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="esp_idf_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (35b658fb1 2024-07-08)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../esp_idf_sys/index.html">esp_idf_sys</a><span class="version">0.35.0</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">esp_idf_sys</a>::<wbr><a class="fn" href="#">mbedtls_x509_crt_verify</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-9a109d5411b517fb/out/bindings.rs.html#38555-38570">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn mbedtls_x509_crt_verify(
    crt: *mut <a class="struct" href="struct.mbedtls_x509_crt.html" title="struct esp_idf_sys::mbedtls_x509_crt">mbedtls_x509_crt</a>,
    trust_ca: *mut <a class="struct" href="struct.mbedtls_x509_crt.html" title="struct esp_idf_sys::mbedtls_x509_crt">mbedtls_x509_crt</a>,
    ca_crl: *mut <a class="struct" href="struct.mbedtls_x509_crl.html" title="struct esp_idf_sys::mbedtls_x509_crl">mbedtls_x509_crl</a>,
    cn: *const c_char,
    flags: *mut u32,
    f_vrfy: Option&lt;unsafe extern &quot;C&quot; fn(arg1: *mut c_void, arg2: *mut <a class="struct" href="struct.mbedtls_x509_crt.html" title="struct esp_idf_sys::mbedtls_x509_crt">mbedtls_x509_crt</a>, arg3: c_int, arg4: *mut u32) -&gt; c_int&gt;,
    p_vrfy: *mut c_void,
) -&gt; c_int</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>\brief          Verify a chain of certificates.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>            The verify callback is a user-supplied callback that
            can clear / modify / add flags <span class="kw">for </span>a certificate. If set,
            the verification callback is called <span class="kw">for </span>each
            certificate <span class="kw">in </span>the chain (from the trust-ca down to the
            presented crt). The parameters <span class="kw">for </span>the callback are:
            (void <span class="kw-2">*</span>parameter, mbedtls_x509_crt <span class="kw-2">*</span>crt, int certificate_depth,
            int <span class="kw-2">*</span>flags). With the flags representing current flags <span class="kw">for
            </span>that specific certificate and the certificate depth from
            the bottom (Peer cert depth = <span class="number">0</span>).

            All flags left after returning from the callback
            are also returned to the application. The function should
            <span class="kw">return </span><span class="number">0 </span><span class="kw">for </span>anything (including invalid certificates)
            other than fatal error, <span class="kw">as </span>a non-zero <span class="kw">return </span>code
            immediately aborts the verification process. For fatal
            errors, a specific error code should be used (different
            from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not
            be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR
            can be used <span class="kw">if </span>no better code is available.</code></pre></div>
<p>\note           In case verification failed, the results can be displayed
using \c mbedtls_x509_crt_verify_info()</p>
<p>\note           Same as \c mbedtls_x509_crt_verify_with_profile() with the
default security profile.</p>
<p>\note           It is your responsibility to provide up-to-date CRLs for
all trusted CAs. If no CRL is provided for the CA that was
used to sign the certificate, CRL verification is skipped
silently, that is <em>without</em> setting any flag.</p>
<p>\note           The \c trust_ca list can contain two types of certificates:
(1) those of trusted root CAs, so that certificates
chaining up to those CAs will be trusted, and (2)
self-signed end-entity certificates to be trusted (for
specific peers you know) - in that case, the self-signed
certificate doesn’t need to have the CA bit set.</p>
<p>\param crt      The certificate chain to be verified.
\param trust_ca The list of trusted CAs.
\param ca_crl   The list of CRLs for trusted CAs.
\param cn       The expected Common Name. This will be checked to be
present in the certificate’s subjectAltNames extension or,
if this extension is absent, as a CN component in its
Subject name. DNS names and IP addresses are fully
supported, while the URI subtype is partially supported:
only exact matching, without any normalization procedures
described in 7.4 of RFC5280, will result in a positive
URI verification.
This may be \c NULL if the CN need not be verified.
\param flags    The address at which to store the result of the verification.
If the verification couldn’t be completed, the flag value is
set to (uint32_t) -1.
\param f_vrfy   The verification callback to use. See the documentation
of mbedtls_x509_crt_verify() for more information.
\param p_vrfy   The context to be passed to \p f_vrfy.</p>
<p>\return         \c 0 if the chain is valid with respect to the
passed CN, CAs, CRLs and security profile.
\return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the
certificate chain verification failed. In this case,
\c *flags will have one or more
\c MBEDTLS_X509_BADCERT_XXX or \c MBEDTLS_X509_BADCRL_XXX
flags set.
\return         Another negative error code in case of a fatal error
encountered during the verification process.</p>
</div></details></section></div></main></body></html>