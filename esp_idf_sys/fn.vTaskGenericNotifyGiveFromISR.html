<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken ); void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken ); @endcode @endcond"><title>vTaskGenericNotifyGiveFromISR in esp_idf_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="esp_idf_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (35b658fb1 2024-07-08)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../esp_idf_sys/index.html">esp_idf_sys</a><span class="version">0.35.0</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">esp_idf_sys</a>::<wbr><a class="fn" href="#">vTaskGenericNotifyGiveFromISR</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-9a109d5411b517fb/out/bindings.rs.html#13243-13247">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn vTaskGenericNotifyGiveFromISR(
    xTaskToNotify: <a class="type" href="type.TaskHandle_t.html" title="type esp_idf_sys::TaskHandle_t">TaskHandle_t</a>,
    uxIndexToNotify: <a class="type" href="type.UBaseType_t.html" title="type esp_idf_sys::UBaseType_t">UBaseType_t</a>,
    pxHigherPriorityTaskWoken: *mut <a class="type" href="type.BaseType_t.html" title="type esp_idf_sys::BaseType_t">BaseType_t</a>,
)</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>@cond !DOC_EXCLUDE_HEADER_SECTION
task. h
@code{c}
void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken );
void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
@endcode
@endcond</p>
<p>A version of xTaskNotifyGiveIndexed() that can be called from an interrupt
service routine (ISR).</p>
<p>See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
to be available.</p>
<p>Each task has a private array of “notification values” (or ‘notifications’),
each of which is a 32-bit unsigned integer (uint32_t).  The constant
configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
array, and (for backward compatibility) defaults to 1 if left undefined.
Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object.  Examples of such
objects are queues, semaphores, mutexes and event groups.  Task notifications
are a method of sending an event directly to a task without the need for such
an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as
update, overwrite or increment one of the task’s notification values.  In
that way task notifications can be used to send data to a task, or be used as
light weight and fast binary or counting semaphores.</p>
<p>vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications
are used as light weight and faster binary or counting semaphore equivalents.
Actual FreeRTOS semaphores are given from an ISR using the
xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
a task notification is vTaskNotifyGiveIndexedFromISR().</p>
<p>When task notifications are being used as a binary or counting semaphore
equivalent then the task being notified should wait for the notification
using the ulTaskNotificationTakeIndexed() API function rather than the
xTaskNotifyWaitIndexed() API function.</p>
<p><strong>NOTE</strong> Each notification within the array operates independently - a task
can only block on one notification within the array at a time and will not be
unblocked by a notification sent to any other array index.</p>
<p>Backward compatibility information:
Prior to FreeRTOS V10.4.0 each task had a single “notification value”, and
all task notification API functions operated on that value. Replacing the
single notification value with an array of notification values necessitated a
new set of API functions that could address specific notifications within the
array.  xTaskNotifyFromISR() is the original API function, and remains
backward compatible by always operating on the notification value at index 0
within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling
xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0.</p>
<p>@param xTaskToNotify The handle of the task being notified.  The handle to a
task can be returned from the xTaskCreate() API function used to create the
task, and the handle of the currently running task can be obtained by calling
xTaskGetCurrentTaskHandle().</p>
<p>@param uxIndexToNotify The index within the target task’s array of
notification values to which the notification is to be sent.  uxIndexToNotify
must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.
xTaskNotifyGiveFromISR() does not have this parameter and always sends
notifications to index 0.</p>
<p>@param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
*pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
task to which the notification was sent to leave the Blocked state, and the
unblocked task has a priority higher than the currently running task.  If
vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
should be requested before the interrupt is exited.  How a context switch is
requested from an ISR is dependent on the port - see the documentation page
for the port in use.</p>
<p>@cond !DOC_SINGLE_GROUP
\defgroup vTaskNotifyGiveIndexedFromISR vTaskNotifyGiveIndexedFromISR
@endcond
\ingroup TaskNotifications</p>
</div></details></section></div></main></body></html>