<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="\brief Export a key in binary format."><title>psa_export_key in esp_idf_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="esp_idf_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (35b658fb1 2024-07-08)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../esp_idf_sys/index.html">esp_idf_sys</a><span class="version">0.35.0</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">esp_idf_sys</a>::<wbr><a class="fn" href="#">psa_export_key</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-9a109d5411b517fb/out/bindings.rs.html#33068-33073">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn psa_export_key(
    key: <a class="type" href="type.mbedtls_svc_key_id_t.html" title="type esp_idf_sys::mbedtls_svc_key_id_t">mbedtls_svc_key_id_t</a>,
    data: *mut u8,
    data_size: usize,
    data_length: *mut usize,
) -&gt; <a class="type" href="type.psa_status_t.html" title="type esp_idf_sys::psa_status_t">psa_status_t</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>\brief Export a key in binary format.</p>
<p>The output of this function can be passed to psa_import_key() to
create an equivalent object.</p>
<p>If the implementation of psa_import_key() supports other formats
beyond the format specified here, the output from psa_export_key()
must use the representation specified here, not the original
representation.</p>
<p>For standard key types, the output format is as follows:</p>
<ul>
<li>For symmetric keys (including MAC keys), the format is the
raw bytes of the key.</li>
<li>For DES, the key data consists of 8 bytes. The parity bits must be
correct.</li>
<li>For Triple-DES, the format is the concatenation of the
two or three DES keys.</li>
<li>For RSA key pairs (#PSA_KEY_TYPE_RSA_KEY_PAIR), the format
is the non-encrypted DER encoding of the representation defined by
PKCS#1 (RFC 8017) as <code>RSAPrivateKey</code>, version 0.
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>RSAPrivateKey ::= SEQUENCE {
    version             INTEGER,  -- must be <span class="number">0
    </span>modulus             INTEGER,  -- n
    publicExponent      INTEGER,  -- e
    privateExponent     INTEGER,  -- d
    prime1              INTEGER,  -- p
    prime2              INTEGER,  -- q
    exponent1           INTEGER,  -- d <span class="kw">mod </span>(p-<span class="number">1</span>)
    exponent2           INTEGER,  -- d <span class="kw">mod </span>(q-<span class="number">1</span>)
    coefficient         INTEGER,  -- (inverse of q) <span class="kw">mod </span>p
}</code></pre></div>
</li>
<li>For elliptic curve key pairs (key types for which
#PSA_KEY_TYPE_IS_ECC_KEY_PAIR is true), the format is
a representation of the private value as a <code>ceiling(m/8)</code>-byte string
where <code>m</code> is the bit size associated with the curve, i.e. the bit size
of the order of the curve’s coordinate field. This byte string is
in little-endian order for Montgomery curves (curve types
<code>PSA_ECC_FAMILY_CURVEXXX</code>), and in big-endian order for Weierstrass
curves (curve types <code>PSA_ECC_FAMILY_SECTXXX</code>, <code>PSA_ECC_FAMILY_SECPXXX</code>
and <code>PSA_ECC_FAMILY_BRAINPOOL_PXXX</code>).
For Weierstrass curves, this is the content of the <code>privateKey</code> field of
the <code>ECPrivateKey</code> format defined by RFC 5915.  For Montgomery curves,
the format is defined by RFC 7748, and output is masked according to §5.
For twisted Edwards curves, the private key is as defined by RFC 8032
(a 32-byte string for Edwards25519, a 57-byte string for Edwards448).</li>
<li>For Diffie-Hellman key exchange key pairs (key types for which
#PSA_KEY_TYPE_IS_DH_KEY_PAIR is true), the
format is the representation of the private key <code>x</code> as a big-endian byte
string. The length of the byte string is the private key size in bytes
(leading zeroes are not stripped).</li>
<li>For public keys (key types for which #PSA_KEY_TYPE_IS_PUBLIC_KEY is
true), the format is the same as for psa_export_public_key().</li>
</ul>
<p>The policy on the key must have the usage flag #PSA_KEY_USAGE_EXPORT set.</p>
<p>\param key               Identifier of the key to export. It must allow the
usage #PSA_KEY_USAGE_EXPORT, unless it is a public
key.
\param[out] data         Buffer where the key data is to be written.
\param data_size         Size of the \p data buffer in bytes.
\param[out] data_length  On success, the number of bytes
that make up the key data.</p>
<p>\retval #PSA_SUCCESS \emptydescription
\retval #PSA_ERROR_INVALID_HANDLE \emptydescription
\retval #PSA_ERROR_NOT_PERMITTED
The key does not have the #PSA_KEY_USAGE_EXPORT flag.
\retval #PSA_ERROR_NOT_SUPPORTED \emptydescription
\retval #PSA_ERROR_BUFFER_TOO_SMALL
The size of the \p data buffer is too small. You can determine a
sufficient buffer size by calling
#PSA_EXPORT_KEY_OUTPUT_SIZE(\c type, \c bits)
where \c type is the key type
and \c bits is the key size in bits.
\retval #PSA_ERROR_COMMUNICATION_FAILURE \emptydescription
\retval #PSA_ERROR_HARDWARE_FAILURE \emptydescription
\retval #PSA_ERROR_CORRUPTION_DETECTED \emptydescription
\retval #PSA_ERROR_STORAGE_FAILURE \emptydescription
\retval #PSA_ERROR_INSUFFICIENT_MEMORY \emptydescription
\retval #PSA_ERROR_BAD_STATE
The library has not been previously initialized by psa_crypto_init().
It is implementation-dependent whether a failure to initialize
results in this error code.</p>
</div></details></section></div></main></body></html>