<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h"><title>xStreamBufferReceiveFromISR in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (35b658fb1 2024-07-08)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_idf_hal</a><span class="version">0.44.1</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In esp_idf_hal::sys</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a>::<wbr><a class="fn" href="#">xStreamBufferReceiveFromISR</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-9a109d5411b517fb/out/bindings.rs.html#13767-13772">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn xStreamBufferReceiveFromISR(
    xStreamBuffer: *mut <a class="struct" href="struct.StreamBufferDef_t.html" title="struct esp_idf_hal::sys::StreamBufferDef_t">StreamBufferDef_t</a>,
    pvRxData: *mut c_void,
    xBufferLengthBytes: usize,
    pxHigherPriorityTaskWoken: *mut i32,
) -&gt; usize</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>@cond !DOC_EXCLUDE_HEADER_SECTION
stream_buffer.h</p>
<p>@code{c}
size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
void *pvRxData,
size_t xBufferLengthBytes,
BaseType_t *pxHigherPriorityTaskWoken );
@endcode
@endcond</p>
<p>An interrupt safe version of the API function that receives bytes from a
stream buffer.</p>
<p>Use xStreamBufferReceive() to read bytes from a stream buffer from a task.
Use xStreamBufferReceiveFromISR() to read bytes from a stream buffer from an
interrupt service routine (ISR).</p>
<p>@param xStreamBuffer The handle of the stream buffer from which a stream
is being received.</p>
<p>@param pvRxData A pointer to the buffer into which the received bytes are
copied.</p>
<p>@param xBufferLengthBytes The length of the buffer pointed to by the
pvRxData parameter.  This sets the maximum number of bytes to receive in one
call.  xStreamBufferReceive will return as many bytes as possible up to a
maximum set by xBufferLengthBytes.</p>
<p>@param pxHigherPriorityTaskWoken  It is possible that a stream buffer will
have a task blocked on it waiting for space to become available.  Calling
xStreamBufferReceiveFromISR() can make space available, and so cause a task
that is waiting for space to leave the Blocked state.  If calling
xStreamBufferReceiveFromISR() causes a task to leave the Blocked state, and
the unblocked task has a priority higher than the currently executing task
(the task that was interrupted), then, internally,
xStreamBufferReceiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE.
If xStreamBufferReceiveFromISR() sets this value to pdTRUE, then normally a
context switch should be performed before the interrupt is exited.  That will
ensure the interrupt returns directly to the highest priority Ready state
task.  *pxHigherPriorityTaskWoken should be set to pdFALSE before it is
passed into the function.  See the code example below for an example.</p>
<p>@return The number of bytes read from the stream buffer, if any.</p>
<p>Example use:
@code{c}
// A stream buffer that has already been created.
StreamBuffer_t xStreamBuffer;</p>
<p>void vAnInterruptServiceRoutine( void )
{
uint8_t ucRxData[ 20 ];
size_t xReceivedBytes;
BaseType_t xHigherPriorityTaskWoken = pdFALSE;  // Initialised to pdFALSE.</p>
<p>// Receive the next stream from the stream buffer.
xReceivedBytes = xStreamBufferReceiveFromISR( xStreamBuffer,
( void * ) ucRxData,
sizeof( ucRxData ),
&amp;xHigherPriorityTaskWoken );</p>
<p>if( xReceivedBytes &gt; 0 )
{
// ucRxData contains xReceivedBytes read from the stream buffer.
// Process the stream here….
}</p>
<p>// If xHigherPriorityTaskWoken was set to pdTRUE inside
// xStreamBufferReceiveFromISR() then a task that has a priority above the
// priority of the currently executing task was unblocked and a context
// switch should be performed to ensure the ISR returns to the unblocked
// task.  In most FreeRTOS ports this is done by simply passing
// xHigherPriorityTaskWoken into taskYIELD_FROM_ISR(), which will test the
// variables value, and perform the context switch if necessary.  Check the
// documentation for the port in use for port specific instructions.
taskYIELD_FROM_ISR( xHigherPriorityTaskWoken );
}
@endcode
@cond !DOC_SINGLE_GROUP
\defgroup xStreamBufferReceiveFromISR xStreamBufferReceiveFromISR
@endcond
\ingroup StreamBufferManagement</p>
</div></details></section></div></main></body></html>