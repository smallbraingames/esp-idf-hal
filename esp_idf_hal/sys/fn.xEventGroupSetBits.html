<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="@cond !DOC_EXCLUDE_HEADER_SECTION event_groups.h @code{c} EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ); @endcode @endcond"><title>xEventGroupSetBits in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (35b658fb1 2024-07-08)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_idf_hal</a><span class="version">0.44.1</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In esp_idf_hal::sys</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a>::<wbr><a class="fn" href="#">xEventGroupSetBits</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-9a109d5411b517fb/out/bindings.rs.html#13689-13692">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn xEventGroupSetBits(
    xEventGroup: *mut <a class="struct" href="struct.EventGroupDef_t.html" title="struct esp_idf_hal::sys::EventGroupDef_t">EventGroupDef_t</a>,
    uxBitsToSet: u32,
) -&gt; u32</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>@cond !DOC_EXCLUDE_HEADER_SECTION
event_groups.h
@code{c}
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
@endcode
@endcond</p>
<p>Set bits within an event group.
This function cannot be called from an interrupt.  xEventGroupSetBitsFromISR()
is a version that can be called from an interrupt.</p>
<p>Setting bits in an event group will automatically unblock tasks that are
blocked waiting for the bits.</p>
<p>@param xEventGroup The event group in which the bits are to be set.</p>
<p>@param uxBitsToSet A bitwise value that indicates the bit or bits to set.
For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
and bit 0 set uxBitsToSet to 0x09.</p>
<p>@return The value of the event group at the time the call to
xEventGroupSetBits() returns.  There are two reasons why the returned value
might have the bits specified by the uxBitsToSet parameter cleared.  First,
if setting a bit results in a task that was waiting for the bit leaving the
blocked state then it is possible the bit will be cleared automatically
(see the xClearBitOnExit parameter of xEventGroupWaitBits()).  Second, any
unblocked (or otherwise Ready state) task that has a priority above that of
the task that called xEventGroupSetBits() will execute and may change the
event group value before the call to xEventGroupSetBits() returns.</p>
<p>Example usage:
@code{c}
#define BIT_0 ( 1 &lt;&lt; 0 )
#define BIT_4 ( 1 &lt;&lt; 4 )</p>
<p>void aFunction( EventGroupHandle_t xEventGroup )
{
EventBits_t uxBits;</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// Set bit 0 and bit 4 in xEventGroup.
 </span>uxBits = xEventGroupSetBits(
                     xEventGroup,    <span class="comment">// The event group being updated.
                     </span>BIT_0 | BIT_4 );<span class="comment">// The bits being set.

 </span><span class="kw">if</span>( ( uxBits &amp; ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
 {
     <span class="comment">// Both bit 0 and bit 4 remained set when the function returned.
 </span>}
 <span class="kw">else if</span>( ( uxBits &amp; BIT_0 ) != <span class="number">0 </span>)
 {
     <span class="comment">// Bit 0 remained set when the function returned, but bit 4 was
     // cleared.  It might be that bit 4 was cleared automatically as a
     // task that was waiting for bit 4 was removed from the Blocked
     // state.
 </span>}
 <span class="kw">else if</span>( ( uxBits &amp; BIT_4 ) != <span class="number">0 </span>)
 {
     <span class="comment">// Bit 4 remained set when the function returned, but bit 0 was
     // cleared.  It might be that bit 0 was cleared automatically as a
     // task that was waiting for bit 0 was removed from the Blocked
     // state.
 </span>}
 <span class="kw">else
 </span>{
     <span class="comment">// Neither bit 0 nor bit 4 remained set.  It might be that a task
     // was waiting for both of the bits to be set, and the bits were
     // cleared as the task left the Blocked state.
 </span>}</code></pre></div>
<p>}
@endcode
@cond !DOC_SINGLE_GROUP
\defgroup xEventGroupSetBits xEventGroupSetBits
@endcond
\ingroup EventGroup</p>
</div></details></section></div></main></body></html>