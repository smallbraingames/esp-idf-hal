<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void vTaskGetRunTimeStats( char *pcWriteBuffer ); @endcode @endcond"><title>vTaskGetRunTimeStats in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (35b658fb1 2024-07-08)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_idf_hal</a><span class="version">0.44.1</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In esp_idf_hal::sys</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a>::<wbr><a class="fn" href="#">vTaskGetRunTimeStats</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-9a109d5411b517fb/out/bindings.rs.html#13204">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn vTaskGetRunTimeStats(pcWriteBuffer: *mut i8)</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>@cond !DOC_EXCLUDE_HEADER_SECTION
task. h
@code{c}
void vTaskGetRunTimeStats( char *pcWriteBuffer );
@endcode
@endcond</p>
<p>Get the state of running tasks as a string</p>
<p>configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
must both be defined as 1 for this function to be available.  The application
must also then provide definitions for
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
to configure a peripheral timer/counter and return the timers current count
value respectively.  The counter should be at least 10 times the frequency of
the tick count.</p>
<p>NOTE 1: This function will disable interrupts for its duration.  It is
not intended for normal application runtime use but as a debug aid.</p>
<p>Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
accumulated execution time being stored for each task.  The resolution
of the accumulated time value depends on the frequency of the timer
configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
Calling vTaskGetRunTimeStats() writes the total execution time of each
task into a buffer, both as an absolute count value and as a percentage
of the total system execution time.</p>
<p>NOTE 2:</p>
<p>This function is provided for convenience only, and is used by many of the
demo applications.  Do not consider it to be part of the scheduler.</p>
<p>vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
uxTaskGetSystemState() output into a human readable table that displays the
amount of time each task has spent in the Running state in both absolute and
percentage terms.</p>
<p>vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
that might bloat the code size, use a lot of stack, and provide different
results on different platforms.  An alternative, tiny, third party, and
limited functionality implementation of sprintf() is provided in many of the
FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
printf-stdarg.c does not provide a full snprintf() implementation!).</p>
<p>It is recommended that production systems call uxTaskGetSystemState() directly
to get access to raw stats data, rather than indirectly through a call to
vTaskGetRunTimeStats().</p>
<p>@param pcWriteBuffer A buffer into which the execution times will be
written, in ASCII form.  This buffer is assumed to be large enough to
contain the generated report.  Approximately 40 bytes per task should
be sufficient.</p>
<p>@cond !DOC_SINGLE_GROUP
\defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
@endcond
\ingroup TaskUtils</p>
</div></details></section></div></main></body></html>