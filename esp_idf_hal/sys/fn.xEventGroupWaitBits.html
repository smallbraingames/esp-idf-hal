<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="@cond !DOC_EXCLUDE_HEADER_SECTION event_groups.h @code{c} EventBits_t xEventGroupWaitBits(    EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, const TickType_t xTicksToWait ); @endcode @endcond"><title>xEventGroupWaitBits in esp_idf_hal::sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="esp_idf_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (35b658fb1 2024-07-08)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../esp_idf_hal/index.html">esp_idf_hal</a><span class="version">0.44.1</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In esp_idf_hal::sys</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="../index.html">esp_idf_hal</a>::<wbr><a href="index.html">sys</a>::<wbr><a class="fn" href="#">xEventGroupWaitBits</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-9a109d5411b517fb/out/bindings.rs.html#13672-13678">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn xEventGroupWaitBits(
    xEventGroup: *mut <a class="struct" href="struct.EventGroupDef_t.html" title="struct esp_idf_hal::sys::EventGroupDef_t">EventGroupDef_t</a>,
    uxBitsToWaitFor: u32,
    xClearOnExit: i32,
    xWaitForAllBits: i32,
    xTicksToWait: u32,
) -&gt; u32</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>@cond !DOC_EXCLUDE_HEADER_SECTION
event_groups.h
@code{c}
EventBits_t xEventGroupWaitBits(    EventGroupHandle_t xEventGroup,
const EventBits_t uxBitsToWaitFor,
const BaseType_t xClearOnExit,
const BaseType_t xWaitForAllBits,
const TickType_t xTicksToWait );
@endcode
@endcond</p>
<p>[Potentially] block to wait for one or more bits to be set within a
previously created event group.</p>
<p>This function cannot be called from an interrupt.</p>
<p>@param xEventGroup The event group in which the bits are being tested.  The
event group must have previously been created using a call to
xEventGroupCreate().</p>
<p>@param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
inside the event group.  For example, to wait for bit 0 and/or bit 2 set
uxBitsToWaitFor to 0x05.  To wait for bits 0 and/or bit 1 and/or bit 2 set
uxBitsToWaitFor to 0x07.  Etc.</p>
<p>@param xClearOnExit If xClearOnExit is set to pdTRUE then any bits within
uxBitsToWaitFor that are set within the event group will be cleared before
xEventGroupWaitBits() returns if the wait condition was met (if the function
returns for a reason other than a timeout).  If xClearOnExit is set to
pdFALSE then the bits set in the event group are not altered when the call to
xEventGroupWaitBits() returns.</p>
<p>@param xWaitForAllBits If xWaitForAllBits is set to pdTRUE then
xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor
are set or the specified block time expires.  If xWaitForAllBits is set to
pdFALSE then xEventGroupWaitBits() will return when any one of the bits set
in uxBitsToWaitFor is set or the specified block time expires.  The block
time is specified by the xTicksToWait parameter.</p>
<p>@param xTicksToWait The maximum amount of time (specified in ‘ticks’) to wait
for one/all (depending on the xWaitForAllBits value) of the bits specified by
uxBitsToWaitFor to become set.</p>
<p>@return The value of the event group at the time either the bits being waited
for became set, or the block time expired.  Test the return value to know
which bits were set.  If xEventGroupWaitBits() returned because its timeout
expired then not all the bits being waited for will be set.  If
xEventGroupWaitBits() returned because the bits it was waiting for were set
then the returned value is the event group value before any bits were
automatically cleared in the case that xClearOnExit parameter was set to
pdTRUE.</p>
<p>Example usage:
@code{c}
#define BIT_0 ( 1 &lt;&lt; 0 )
#define BIT_4 ( 1 &lt;&lt; 4 )</p>
<p>void aFunction( EventGroupHandle_t xEventGroup )
{
EventBits_t uxBits;
const TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// Wait a maximum of 100ms for either bit 0 or bit 4 to be set within
 // the event group.  Clear the bits before exiting.
 </span>uxBits = xEventGroupWaitBits(
             xEventGroup,    <span class="comment">// The event group being tested.
             </span>BIT_0 | BIT_4,  <span class="comment">// The bits within the event group to wait for.
             </span>pdTRUE,         <span class="comment">// BIT_0 and BIT_4 should be cleared before returning.
             </span>pdFALSE,        <span class="comment">// Don't wait for both bits, either bit will do.
             </span>xTicksToWait ); <span class="comment">// Wait a maximum of 100ms for either bit to be set.

 </span><span class="kw">if</span>( ( uxBits &amp; ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
 {
     <span class="comment">// xEventGroupWaitBits() returned because both bits were set.
 </span>}
 <span class="kw">else if</span>( ( uxBits &amp; BIT_0 ) != <span class="number">0 </span>)
 {
     <span class="comment">// xEventGroupWaitBits() returned because just BIT_0 was set.
 </span>}
 <span class="kw">else if</span>( ( uxBits &amp; BIT_4 ) != <span class="number">0 </span>)
 {
     <span class="comment">// xEventGroupWaitBits() returned because just BIT_4 was set.
 </span>}
 <span class="kw">else
 </span>{
     <span class="comment">// xEventGroupWaitBits() returned because xTicksToWait ticks passed
     // without either BIT_0 or BIT_4 becoming set.
 </span>}</code></pre></div>
<p>}
@endcode
@cond !DOC_SINGLE_GROUP
\defgroup xEventGroupWaitBits xEventGroupWaitBits
@endcond
\ingroup EventGroup</p>
</div></details></section></div></main></body></html>