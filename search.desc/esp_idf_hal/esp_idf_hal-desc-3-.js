searchState.loadedDescShard("esp_idf_hal", 3, "&lt; Service type\n&lt; Type of smartconfig(ESPTouch or AirKiss).\n@ref lwip_ip_addr_type\n&lt; option type\n&lt; partition type (app/data)\n&lt; The SAN type, value of MBEDTLS_X509_SAN_XXX.\n&lt; Type of stored key-value pair\n&lt; I2S event type\n&lt; UART event type\n&lt; The type id.\na bit field indicating pbuf type and allocation sources …\n&lt; IP address union\n&lt; IP address union\n@brief UART AT cmd char configuration parameters Note that …\n@brief Clear UART interrupt status\n@brief UART configuration parameters for uart_param_config …\n@brief Clear UART interrupt enable bits\n@brief   UART disable pattern detect function. Designed …\n@brief Disable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT …\n@brief Disable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT …\n@brief Uninstall UART driver.\n@brief Install UART driver and set the UART to the default …\n@brief Set UART interrupt enable\n@brief UART enable pattern detect function. Designed for …\n@brief Enable UART RX interrupt (RX_FULL &amp; RX_TIMEOUT …\n@brief Enable UART TX interrupt (TX_FULL &amp; TX_TIMEOUT …\n@brief Event structure used in UART event queue\n@brief UART event types used in the ring buffer\n&lt; UART break event\n&lt; UART RX buffer full event\n&lt; UART data event\n&lt; UART TX data and break event\n&lt; UART event max index\n&lt; UART FIFO overflow event\n&lt; UART RX frame error event\n&lt; UART RX parity event\n&lt; UART pattern detected\n&lt; UART wakeup event\n@brief Alias of uart_flush_input. UART ring buffer flush. …\n@brief Clear input buffer, discard all the data is in the …\n@brief Get the UART baud rate configuration.\n@brief   UART get RX ring buffer cached data length\n@brief Returns collision detection flag for RS485 mode …\n@brief Get the UART hardware flow control configuration.\n@brief Get the UART parity mode configuration.\n@brief Get the frequency of a clock source for the UART\n@brief Get mutex guarding select() notifications\n@brief Get the UART stop bit configuration.\n@brief   UART get TX ring buffer free space size\n@brief Get the number of RX pin signal edges for light …\n@brief Get the UART data bit configuration.\n@brief UART hardware flow control modes\n&lt; enable TX hardware flow control (cts)\n&lt; enable hardware flow control\n&lt; disable hardware flow control\n&lt; enable RX hardware flow control (rts)\n@brief Configure UART interrupts.\n@brief UART interrupt configuration parameters for …\n@brief Checks whether the driver is installed or not\n@brief UART mode selection\n&lt; mode: IRDA  UART mode\n&lt; mode: application control RS485 UART mode (used for test …\n&lt; mode: RS485 collision detection UART mode (used for test …\n&lt; mode: half duplex RS485 UART mode control by RTS pin\n&lt; mode: regular UART mode\n@brief Set UART configuration parameters.\n@brief UART parity constants\n&lt; Disable UART parity\n&lt; Enable UART even parity\n&lt; Enable UART odd parity\n@brief Return the nearest detected pattern position in …\n@brief Return the nearest detected pattern position in …\n@brief Allocate a new memory with the given length to save …\n@brief UART port number, can be UART_NUM_0 ~ (UART_NUM_MAX …\n@brief UART read bytes from UART buffer\n@brief Type of UART clock source, reserved for the legacy …\n@brief Configure behavior of UART RX timeout interrupt.\n@brief Set UART baud rate.\n@brief Manually set the UART DTR pin level.\n@brief Set hardware flow control.\n@brief Set UART line inverse mode\n@brief Configure TX signal loop back to RX module, just …\n@brief UART set communication mode\n@brief Set UART parity mode.\n@brief Assign signals of a UART peripheral to GPIO pins\n@brief Manually set the UART RTS pin level. @note  UART …\n@brief Set uart threshold value for RX fifo full @note If …\n@brief UART set threshold timeout for TOUT feature\n@brief Set notification callback function for select() …\n@brief Set UART stop bits.\n@brief Set software flow control.\n@brief Set uart threshold values for TX fifo empty\n@brief Set UART idle interval after tx FIFO is empty\n@brief Set the number of RX pin signal edges for light …\n@brief Set UART data bits.\n@brief UART signal bit map\n&lt; inverse the UART cts signal\n&lt; inverse the UART dsr signal\n&lt; inverse the UART dtr signal\n&lt; Disable UART signal inverse\n&lt; inverse the UART irda_rx signal\n&lt; inverse the UART irda_tx signal\n&lt; inverse the UART rts signal\n&lt; inverse the UART rxd signal\n&lt; inverse the UART txd signal\n@brief UART stop bits number\n&lt; stop bit: 1bit\n&lt; stop bit: 1.5bits\n&lt; stop bit: 2bits\n@brief UART software flow control configuration parameters\n@brief Send data to the UART port from a given buffer and …\n@brief Wait until UART TX FIFO is empty.\n@brief Wait until UART tx memory empty and the last char …\n@brief UART word length constants\n&lt; word length: 5bits\n&lt; word length: 6bits\n&lt; word length: 7bits\n&lt; word length: 8bits\n@brief Send data to the UART port from a given buffer and …\n@brief Send data to the UART port from a given buffer and …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code uint32_t …\n&lt; ADC controlled by ULP, see <code>adc_ulp_mode_t</code>\n&lt; ADC unit\n&lt; ADC unit\n&lt; ADC unit\n&lt; unlink without context pointer\n&lt; unlink with context pointer\n&lt; The buffer for the unstructured types. rfc822Name, …\n&lt; Number of unused bits at the end of the string\n&lt; Number of unused bits at the end of the string\n&lt; Up-sampling param fp\n&lt; Up-sampling param fs, not allowed to be greater than 480\n&lt; Indicates whether publisher’s service ID needs to be …\n&lt; The URI of this request (1 byte extra for null …\n&lt; The URI to handle\n&lt; The URI of this request (1 byte extra for null …\n&lt; The URI to handle\n&lt; Complete <em>MQTT</em> broker URI\nURI matcher function.\nURI matcher function.\n&lt; HTTP URL, the information on the URL is most important, …\n@brief Configuration structure for the …\n@brief Install USB-SERIAL-JTAG driver and set the …\n@brief Uninstall USB-SERIAL-JTAG driver.\n@brief Check if the USB Serial/JTAG port is connected to …\n@brief USB_SERIAL_JTAG read bytes from USB_SERIAL_JTAG …\n@brief Send data to the USB-UART port from a given buffer …\n&lt; I2S using APLL as main I2S clock, enable it to get …\n&lt; I2S using APLL as main I2S clock, enable it to get …\n&lt; Use a global ca_store for all the connections in which …\n&lt; Use a global ca_store for all the connections in which …\n&lt; Use a global ca_store for all the connections in which …\n&lt; Use a global ca_store, look esp-tls documentation for …\n&lt; Enable this option to use secure element or atecc608a …\n&lt; Enable this option to use secure element or atecc608a …\n&lt; Enable secure element, available in ESP32-ROOM-32SE, for …\n&lt; Amount of used entries.\n&lt; User-defined variable. Can be used to store eg …\n&lt; User-defined variable. Can be used to store eg …\n&lt; The User Agent string to send with HTTP requests\n&lt; WS user agent\nUser context pointer passed during URI registration.\nPointer to user context data which will be available to …\nUser context pointer passed during URI registration.\nPointer to user context data which will be available to …\n&lt; User private data, passed directly to on_color_trans_done…\n&lt; User private data, passed directly to on_color_trans_done…\n&lt; user_data context, from esp_http_client_config_t …\n&lt; user_data context, from esp_http_client_config_t …\n&lt; HTTP user_data context\nUser context data to pass as parameter to callback function\n&lt; User data, used to store externally customized data\n&lt; Using for Http authentication\n&lt; <em>MQTT</em> username\n&lt; utime without context pointer\n&lt; utime with context pointer\nUUID to be assigned to the BLE characteristic which is …\nUUID to be assigned to the BLE characteristic which is …\n@cond !DOC_EXCLUDE_HEADER_SECTION queue. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION queue. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@brief Fill an array of TaskSnapshot_t structures for …\n@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code{c} …\nconfigUSE_TRACE_FACILITY must be defined as 1 in …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\nUBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer );\n&lt; Optional X.509 v3 extensions.\n@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code{c} void …\n@brief Hook function called on entry to tickless idle\n@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION event_groups.h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION\n@brief Clear current interrupt mask and set given mask\n@brief Enter a critical section\n@brief Exit a critical section\n@brief Set interrupt mask and return current interrupt …\n@brief Set a watchpoint to watch the last 32 bytes of the …\n@brief Perform a context switch from a task\n@brief Perform a context switch from an ISR\n@brief Yields the other core\n@cond !DOC_EXCLUDE_HEADER_SECTION queue. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION\n@brief   Delete a ring buffer\n@brief   Get information about ring buffer status\n@brief   Return a previously-retrieved item to the ring …\n@brief   Return a previously-retrieved item to the ring …\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@brief Fill a TaskSnapshot_t structure for specified task.\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\nSet local storage pointer specific to the given task.\nSet local storage pointer and deletion callback.\n@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\nvoid vTimerSetReloadMode( TimerHandle_t xTimer, const …\nvoid vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID …\n&lt; The named value.\n&lt;Raw data value\n&lt; option value\n&lt; The named value.\n&lt; The named value.\n&lt; Equivalent unsigned value for the RMT item\n&lt; Equivalent unsigned value for the RMT symbol\n&lt; Start time of certificate validity.\n&lt; End time of certificate validity.\n&lt; vendor specific configuration, optional, left as NULL if …\n@brief Vendor Information Element header\n&lt; Vendor identifier (OUI).\n&lt; Vendor-specific OUI type.\nUnique version number of security implementation\nUnique version number of security implementation\n&lt; Security verification of the broker\nPointer to the buffer containing the verifier\nPointer to the buffer containing the verifier\nPointer to the buffer containing the verifier\nLength (in bytes) of the verifier\nLength (in bytes) of the verifier\nLength (in bytes) of the verifier\n&lt; ADC Calibration\n&lt; CRL version (1=v1, 2=v2)\n&lt; The X.509 version. (1=v1, 2=v2, 3=v3)\n&lt; Application version\n&lt; max vote times in self-healing, default:1000\n&lt; voter address\n&lt; vote RSSI of the router\n&lt; vote started\n&lt; vote ttl\n&lt; votes\n&lt; Vref used by lookup table\n&lt; if true, we create a semaphore to signal time sync event\n&lt; if true, we create a semaphore to signal time sync event\n&lt; wait_high_period time\n&lt; Warm up time before assuming NAN Anchor Master role\n@brief     The Rx callback function of Action Tx operations\n@brief Action Frame Tx Request\n@brief Range of active scan times per channel\n@brief WiFi antenna configuration\n@brief WiFi GPIOs configuration for antenna selection\n@brief WiFi GPIO configuration for antenna selection\n@brief WiFi antenna mode\n&lt; Enable WiFi antenna 0 only\n&lt; Enable WiFi antenna 1 only\n&lt; Enable WiFi antenna 0 and 1, automatically select an …\n&lt; Invalid WiFi enabled antenna\n@brief WiFi antenna\n&lt; WiFi antenna 0\n&lt; WiFi antenna 1\n&lt; Invalid WiFi antenna\n@brief Soft-AP configuration settings for the device\n@brief Description of a WiFi AP\n&lt; authenticate mode : WiFi EAP security\n&lt; authenticate mode : open\n&lt; authenticate mode : OWE\n&lt; authenticate mode : WAPI_PSK\n&lt; authenticate mode : WEP\n&lt; authenticate mode : WiFi EAP security\n&lt; authenticate mode : WPA2_PSK\n&lt; authenticate mode : WPA2_WPA3_PSK\n&lt; authenticate mode : WPA3_ENT_SUITE_B_192_BIT\n&lt; authenticate mode : WPA3_PSK\n&lt; authenticate mode : WPA_PSK\n&lt; authenticate mode : WPA_WPA2_PSK\n@brief WiFi beacon monitor parameter configuration\n@brief Disable Wi-Fi and BT common module\n@brief Enable Wi-Fi and BT common module\n@brief     Callocate memory for WiFi driver\n&lt; the cipher type is AES-CMAC-128\n&lt; the cipher type is AES-GMAC-128\n&lt; the cipher type is AES-GMAC-256\n&lt; the cipher type is CCMP\n&lt; the cipher type is GCMP\n&lt; the cipher type is GCMP-256\n&lt; the cipher type is none\n&lt; the cipher type is SMS4\n&lt; the cipher type is TKIP\n&lt; the cipher type is TKIP and CCMP\n&lt; the cipher type is unknown\n&lt; the cipher type is WEP104\n&lt; the cipher type is WEP40\n@brief Configuration data for device’s AP or STA or NAN.\n&lt; Country policy is auto, use the country info of AP to …\n&lt; Country policy is manual, always use the configured …\n@brief Structure describing WiFi country-based regional …\n@brief The RX callback function of Channel State …\n@brief CSI data type\nArgument structure for WIFI_EVENT_ACTION_TX_STATUS event\nArgument structure for WIFI_EVENT_AP_PROBEREQRECVED event\nArgument structure for WIFI_EVENT_AP_STACONNECTED event\nArgument structure for WIFI_EVENT_AP_STADISCONNECTED event\nArgument structure for WIFI_EVENT_AP_WPS_RG_FAILED event\nArgument structure for WIFI_EVENT_AP_WPS_RG_PIN event\nArgument structure for WIFI_EVENT_AP_WPS_RG_SUCCESS event\nArgument structure for WIFI_EVENT_STA_BSS_RSSI_LOW event\nArgument structure for WIFI_EVENT_FTM_REPORT event\nArgument structure for WIFI_EVENT_NAN_RECEIVE event\nArgument structure for WIFI_EVENT_NAN_REPLIED event\nArgument structure for WIFI_EVENT_NAN_SVC_MATCH event\nArgument structure for WIFI_EVENT_NDP_CONFIRM event\nArgument structure for WIFI_EVENT_NDP_INDICATION event\nArgument structure for WIFI_EVENT_NDP_TERMINATED event\nArgument structure for WIFI_EVENT_ROC_DONE event\nArgument structure for WIFI_EVENT_STA_AUTHMODE_CHANGE event\nArgument structure for WIFI_EVENT_STA_CONNECTED event\nArgument structure for WIFI_EVENT_STA_DISCONNECTED event\nArgument structure for WIFI_EVENT_SCAN_DONE event\nArgument structure for WIFI_EVENT_STA_WPS_ER_PIN event\nArgument structure for WIFI_EVENT_STA_WPS_ER_SUCCESS event\nArgument structure for WIFI_EVENT_STA_WPS_ER_FAILED event\n&lt; WPS normal fail reason\n&lt; WPS receive M2D frame\nWiFi event declarations\n&lt; Status indication of Action Tx operation\n&lt; Receive probe request packet in soft-AP interface\n&lt; a station connected to Soft-AP\n&lt; a station disconnected from Soft-AP\n&lt; Soft-AP start\n&lt; Soft-AP stop\n&lt; Soft-AP wps fails in registrar mode\n&lt; Soft-AP wps overlap in registrar mode\n&lt; Soft-AP wps pin code in registrar mode\n&lt; Soft-AP wps succeeds in registrar mode\n&lt; Soft-AP wps timeout in registrar mode\n&lt; Connectionless module wake interval start\n&lt; Receive report of FTM procedure\n&lt; iTWT probe\n&lt; iTWT setup\n&lt; iTWT suspend\n&lt; iTWT teardown\n&lt; Invalid WiFi event ID\n&lt; Received a Follow-up message\n&lt; Replied to a NAN peer with Service Discovery match\n&lt; NAN Discovery has started\n&lt; NAN Discovery has stopped\n&lt; NAN Service Discovery match found\n&lt; NDP Confirm Indication\n&lt; Received NDP Request from a NAN Peer\n&lt; NAN Datapath terminated indication\n&lt; Remain-on-Channel operation complete\n&lt; Finished scanning AP\n&lt; the auth mode of AP connected by device’s station …\n&lt; Station beacon timeout\n&lt; AP’s RSSI crossed configured threshold\n&lt; Station connected to AP\n&lt; Station disconnected from AP\n&lt; Station start\n&lt; Station stop\n&lt; Station wps fails in enrollee mode\n&lt; Station wps overlap in enrollee mode\n&lt; Station wps pin code in enrollee mode\n&lt; Station wps succeeds in enrollee mode\n&lt; Station wps timeout in enrollee mode\n&lt; WiFi ready\n@brief FTM Initiator configuration\nArgument structure for\n@brief FTM operation status types\n&lt; Peer rejected FTM configuration in FTM Request\n&lt; Unknown error during FTM exchange\n&lt; Peer did not respond to FTM Requests\n&lt; FTM exchange is successful\n&lt; Peer does not support FTM\n@brief Description of a WiFi AP HE Info\n@brief Configuration for STA’s HT2040 coexist management\n@brief WiFi stack configuration parameters passed to …\n@brief WiFi ioctl command type\n&lt; Get the configuration of STA’s HT2040 coexist …\n&lt; Set the configuration of STA’s HT2040 coexist …\n@brief Configuration for WiFi ioctl\n@brief WiFi log level\n@brief WiFi log module definition\n@brief     Update WiFi MAC time\n@brief     Allocate a chunk of memory for WiFi driver\nSets mode of operation of Wi-Fi during provisioning This …\nSets mode of operation of Wi-Fi during provisioning This …\n&lt; WiFi soft-AP mode\n&lt; WiFi station + soft-AP mode\n&lt; WiFi NAN mode\n&lt; null mode\n&lt; WiFi station mode\n@brief Disable Wi-Fi module\n@brief Enable Wi-Fi module\n@brief NAN Discovery start configuration\n@brief NAN Datapath End parameters\n@brief NAN Datapath Request parameters\n@brief NAN Datapath Response parameters\n@brief NAN Follow-up parameters\n@brief NAN Publish service configuration parameters\n@brief NAN Services types\n&lt; Send unicast Publish frame to Subscribers that match the …\n&lt; Send broadcast Publish frames in every Discovery …\n&lt; Send broadcast Subscribe frames in every DW\n&lt; Passively listens to Publish frames\n@brief NAN Subscribe service configuration parameters\n@brief Forward declaration of WiFi interface handle\n@brief     The net stack buffer free callback function\n@brief     The net stack buffer reference counter callback …\n@brief     Operation Phymode\n&lt; PHY mode for 11b\n&lt; PHY mode for 11g\n&lt; PHY mode for Bandwidth HE20\n&lt; PHY mode for Bandwidth HT20\n&lt; PHY mode for Bandwidth HT40\n&lt; PHY mode for Low Rate\n@brief WiFi PHY rate encodings\n&lt; 11 Mbps with long preamble\n&lt; 11 Mbps with short preamble\n&lt; 12 Mbps\n&lt; 18 Mbps\n&lt; 1 Mbps with long preamble\n&lt; 24 Mbps\n&lt; 2 Mbps with long preamble\n&lt; 2 Mbps with short preamble\n&lt; 36 Mbps\n&lt; 48 Mbps\n&lt; 54 Mbps\n&lt; 5.5 Mbps with long preamble\n&lt; 5.5 Mbps with short preamble\n&lt; 6 Mbps\n&lt; 9 Mbps */ /**&lt; rate table and guard interval information …\n&lt; 250 Kbps\n&lt; 500 Kbps\n&lt; MCS0 with long GI\n&lt; MCS0 with short GI\n&lt; MCS1 with long GI\n&lt; MCS1 with short GI\n&lt; MCS2 with long GI\n&lt; MCS2 with short GI\n&lt; MCS3 with long GI\n&lt; MCS3 with short GI\n&lt; MCS4 with long GI\n&lt; MCS4 with short GI\n&lt; MCS5 with long GI\n&lt; MCS5 with short GI\n&lt; MCS6 with long GI\n&lt; MCS6 with short GI\n&lt; MCS7 with long GI\n&lt; MCS7 with short GI\n@brief Received packet radio metadata header, this is the …\nConfiguration structure for Protected Management Frame\n@brief The RX callback function in the promiscuous mode. …\n@brief Mask for filtering different packet types in …\n@brief Payload passed to ‘buf’ parameter of …\n@brief Promiscuous frame type\n&lt; Control frame, indicates ‘buf’ argument is …\n&lt; Data frame, indiciates ‘buf’ argument is …\n&lt; Management frame, indicates ‘buf’ argument is …\n&lt; Other type, such as MIMO etc. ‘buf’ argument is …\n@brief   Events generated by manager\nEmitted when device fails to connect to the AP of which the\nEmitted when Wi-Fi AP credentials are received via …\nEmitted when device successfully connects to the AP of …\nSignals that manager has been de-initialized\nSignals that provisioning service has stopped\nEmitted when the manager is initialized\nIndicates that provisioning has started\n@brief   Handler for receiving and responding to requests …\n@brief   WiFi status data to be sent in response to …\n@brief   Internal handlers for receiving and responding to …\n@brief   Internal handlers for receiving and responding to …\n@brief   WiFi config data received by slave during …\n@brief   Type of context data passed to each get/set/apply …\n@brief   Event handler that is used by the manager while …\n@brief   Structure for specifying the manager configuration\n@brief   Runs Wi-Fi as Station with the supplied …\n@brief   Stop provisioning (if running) and release …\n@brief   Disable auto stopping of provisioning service …\n@brief   Create an additional endpoint and allocate …\n@brief   Register a handler for the previously created …\n@brief   Unregister the handler for an endpoint\n@brief   Get reason code in case of Wi-Fi station …\n@brief   Get state of Wi-Fi Station during provisioning\n@brief   Initialize provisioning manager instance\n@brief   Checks if device is provisioned\n@brief   Reset Wi-Fi provisioning config\n@brief   Reset internal state machine and clear …\n@brief   Reset internal state machine and clear …\n@brief   Set application version and capabilities in the …\n@brief   Start provisioning service\n@brief   Stop provisioning service\n@brief   Wait for provisioning service to finish\n@brief   Structure for specifying the provisioning scheme …\n@brief   Scheme that can be used by manager for …\n@brief   Set manufacturer specific data in scan response\n@brief   Set the 128 bit GATT service UUID used for …\n@brief   Scheme that can be used by manager for …\n@brief Provide HTTPD Server handle externally.\n@brief   Structure for specifying the provisioning scheme …\n@brief   Security modes supported by the Provisioning …\n@brief  Security 1 params structure This needs to be …\n@brief  Security 2 params structure This needs to be …\nNo security (plain-text communication)\nThis secure communication mode consists of X25519 key …\nThis secure communication mode consists of SRP6a based …\n@brief   Security modes supported by the Provisioning …\n@brief   WiFi STA connected status information\n@brief   WiFi STA connection fail reason\n@brief   WiFi STA status for conveying back to the …\n&lt; Maximum modem power saving. In this mode, interval to …\n&lt; Minimum modem power saving. In this mode, station wakes …\n&lt; No power save\n@brief     Reallocate a chunk of memory for WiFi driver\n@brief     The WiFi RX callback function\nConfiguration for SAE-PK\nConfiguration for SAE PWE derivation\n@brief Parameters for an SSID scan.\n&lt; All channel scan, scan will end after scan all the …\n&lt; Do fast scan, scan will end after find SSID match AP\n@brief Structure describing parameters for a WiFi fast scan\n@brief Aggregate of active &amp; passive scan time per channel\n&lt; active scan\n&lt; passive scan\n&lt; the channel width is HT40 and the secondary channel is …\n&lt; the channel width is HT40 and the secondary channel is …\n&lt; the channel width is HT20\n&lt; Sort match AP in scan list by security mode\n&lt; Sort match AP in scan list by RSSI\n@brief STA configuration settings for the device\n@brief Description of STA associated with AP\n@brief List of stations associated with the Soft-AP\n&lt; WiFi state of the station\n&lt; all configuration will store in both memory and flash\n&lt; all configuration will only store in the memory\n&lt; WiFi Task Core ID\n@breif    TxDone callback function type. Should be …\n@brief     Vendor Information Element index\n@brief     Vendor Information Element type\n@brief Erase part of the WL storage\n@brief wear levelling handle\n@brief Mount WL for defined partition\n@brief Read data from the WL storage\n@brief Get sector size of the WL instance\n@brief Get size of the WL storage\n@brief Unmount WL for defined partition\n@brief Write data to the WL storage\n&lt; WP pin when SPI pins set via efuse (read by ROM …\n&lt; WiFi station crypto functions when connect\n@brief The crypto callback function structure used when do …\n@brief Structure representing WPS factory information for …\n&lt; WPS failed during auth\n&lt; WPS failed due to incorrect config\n&lt; WPS normal fail reason\n@brief Enumeration of WPS (Wi-Fi Protected Setup) types.\n&lt; The type of WPS to be used (PBC or PIN).\n&lt; WPS is disabled\n&lt; Maximum value for WPS type enumeration\n&lt; WPS Push Button Configuration method\n&lt; WPS PIN (Personal Identification Number) method\n@brief Enumeration of WPS (Wi-Fi Protected Setup) types.\n&lt; Write without context pointer\n&lt; sector write function\nSlicer for write data. The <code>program_page</code> should be called …\nSlicer for write data. The <code>program_page</code> should be called …\n&lt; Write with context pointer\n@brief Write PHY register\n@brief Write PHY register\n@brief Write PHY register\n&lt; WS pin, input in slave role, output in master role\n&lt; WS pin, input in slave role, output in master role\n&lt; WS pin, input in slave role, output in master role\n&lt; HTTP path to update protocol to websocket\n&lt; WS signal polarity, set true to enable high lever first\n&lt; WS signal polarity, set true to enable high lever first\n&lt; not a valid opcode to indicate no message previously …\n&lt; WS signal width (i.e. the number of bclk ticks that ws …\n&lt; WS signal width (i.e. the number of bclk ticks that ws …\n@cond\n@cond\n@cond !DOC_EXCLUDE_HEADER_SECTION event_groups.h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION event_groups.h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION event_groups.h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION event_groups.h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION event_groups.h @code{c} …\nDefines the memory ranges allocated to the task when an …\n@brief Checks if a given piece of memory can be used to …\n@brief Get the tick rate per second\n@brief Checks if the current core is in an ISR context\n@brief Check if in ISR context from High priority ISRs\n@brief Checks if a given piece of memory can be used to …\nAdds a queue or semaphore to a queue set that was …\n@cond !DOC_EXCLUDE_HEADER_SECTION\nFor internal use only.  Use xSemaphoreCreateMutex(), …\nQueue sets provide a mechanism to allow a task to block …\n@cond !DOC_EXCLUDE_HEADER_SECTION queue. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION queue. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION queue. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION queue. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION queue. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION queue. h @code{c} …\nRemoves a queue or semaphore from a queue set.  A queue or …\nxQueueSelectFromSet() selects from the members of a queue …\nA version of xQueueSelectFromSet() that can be used from …\nFor internal use only.  Use xSemaphoreTakeMutexRecursive() …\n@brief   Add the ring buffer to a queue set. Notified when …\n@brief       Create a ring buffer\n@brief Create a ring buffer of type RINGBUF_TYPE_NOSPLIT …\n@brief       Create a ring buffer but manually provide the …\n@brief   Get current free size available for an item/data …\n@brief   Get maximum size of an item that can be placed in …\n@brief   Debugging function to print the internal pointers …\n@brief   Retrieve an item from the ring buffer\n@brief   Retrieve an item from the ring buffer in an ISR\n@brief   Retrieve a split item from an allow-split ring …\n@brief   Retrieve a split item from an allow-split ring …\n@brief   Retrieve bytes from a byte buffer, specifying the …\n@brief   Retrieve bytes from a byte buffer, specifying the …\n@brief   Remove the ring buffer from a queue set\n@brief       Insert an item into the ring buffer\n@brief Acquire memory from the ring buffer to be written …\n@brief       Actually send an item into the ring buffer …\n@brief       Insert an item into the ring buffer in an ISR\n@brief Struct that is equivalent in size to the ring buffer…\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@cond !DOC_EXCLUDE_HEADER_SECTION stream_buffer.h\n@brief Task Snapshot structure\nUsed internally only.\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task.h @code BaseType_t …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\nxTaskGetIdleTaskHandle() is only available if …\nGet the handle of idle task for the given CPU.\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} …\n@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} void …\n@cond !DOC_EXCLUDE_HEADER_SECTION\nTickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );\nTickType_t xTimerGetPeriod( TimerHandle_t xTimer );\nTaskHandle_t xTimerGetTimerDaemonTaskHandle( void );\nBaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );\nBaseType_t xTimerPendFunctionCall( PendedFunction_t …\nBaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t …\n&lt; Xoff flow control char\n&lt; If the software flow control is enabled and the data …\n&lt; Xon flow control char\n&lt; If the software flow control is enabled and the data …\n&lt; Date.\nYield to other tasks. Called during erase operations.\n&lt; zone ID\n&lt; zone ID\nBuild time in the local timescale.\nBuild time in UTC.\nCamel case, eg: <code>fooBarBaz</code>. The first character is always …\nThe casing style of a string.\nKebab case, eg: <code>foo-bar-baz</code>. Also turns the string …\nLowercase\nWrapper for many std types, which implements the …\nPascal case, eg: <code>FooBarBaz</code>. The first character is always …\nSnake case, eg: <code>foo_bar_baz</code>. Also turns the string …\nThe return value of <code>str_splice</code>\nUppercase\nKebab case, eg: <code>FOO-BAR-BAZ</code>. Also turns the string …\nSnake case, eg: <code>FOO_BAR_BAZ</code>. Also turns the string …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how much space is necessary to write the wrapped …\nComputes how much space is necessary to write …\nConcatenates constants of primitive types into a …\nFormats constants of primitive types into a <code>&amp;&#39;static str</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nComputes how long much space is necessary to write this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the casing style of a <code>&amp;&#39;static str</code> constant, …\nA string that had <code>removed</code> replaced with some other string.\nThe part of the string that was removed.\nFor constructing from a reference to an array.\nIndexes a <code>&amp;&#39;static str</code> constant, returning <code>None</code> when the …\nIndexes a <code>&amp;&#39;static str</code> constant.\nCreates a <code>&amp;&#39;static str</code> by repeating a <code>&amp;&#39;static str</code> …\nReplaces all the instances of <code>$pattern</code> in <code>$input</code> (a …\nReplaces a substring in a <code>&amp;&#39;static str</code> constant. Returns …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer, as the …\nReturns the absolute value of this integer.\nReturns the absolute value of this integer, as the …\nExecutes the supplied future on the current thread, thus …\nCreates a FreeRTOS task.\nDeletes a FreeRTOS task.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a new <code>CriticalSection</code> instance\nSafety\nSafety\nExample\nYield from the current task once, allowing other tasks to …\nSingle-slot lock-free signaling primitive supporting …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Notification</code>.\nMarks the supplied bits in this <code>Notification</code> as notified. …\nMarks the least significant bit (bit 0) in this …\nA utility to help in implementing a custom <code>wait</code> logic: …\nNon-blocking method to check whether this notification has …\nClears the state of this notification by removing any …\nFuture that completes when this <code>Notification</code> has been …\nA mutex that allows borrowing data across executors but …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>EspRawMutex</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSafety\nSafety\nThin wrapper on top of the FreeRTOS queue.\nRetrieves the underlying FreeRTOS handle.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAllocate a new queue on the heap.\nCreate a new queue which is not deleted on <code>Drop</code>, but owned …\nCopy the first message from the queue without removing it.\nReceive a message from the queue and remove it.\nCopy item to back of queue, blocking for <code>timeout</code> ticks if …\nCopy item to front of queue, blocking for <code>timeout</code> ticks if …\nFlags to indicate the capabilities of the various memo\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSafety\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the configured alarm value\nEnable or disable counter reload function when alarm event …\nTimer configuration\nReturns the current counter value of the timer\nDelays for <code>counter</code> ticks\nEnable or disable the timer.\nEnable or disable the alarm.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSafety\nSafety\nResets the internal wait notification\nSet the alarm value of the timer.\nManually set the current counter value of the timer.\nSubscribes the provided callback for ISR notifications. As …\nSubscribes the provided callback for ISR notifications. As …\nReturns the tick rate of the timer.\nWait for an alarm interrupt to occur\nEnable or disable counter reload function when alarm event …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents DATA event with timeout_flag set\nUART data was received and/or a timeout was triggered\nSerial abstraction\nSerial receiver\nSerial transmitter\nReturns the current baudrate\nReturns the current baudrate\nReturns the current baudrate\nChange the baudrate.\nChange the baudrate.\nChange the baudrate.\nChange the number of data bits\nChange the number of data bits\nChange the number of data bits\nChange the type of parity checking\nChange the type of parity checking\nChange the type of parity checking\nChange the number of stop bits\nChange the number of stop bits\nChange the number of stop bits\nClears the receive buffer.\nUART configuration\nGet count of remaining bytes in the receive ring buffer\nGet count of remaining capacity in the transmit ring buffer\nReturn the current number of data bits\nReturn the current number of data bits\nReturn the current number of data bits\nConfigures the interrupts the driver should enable.\nRetrieves the event queue for this UART. Returns <code>None</code> if …\nRetrieves the event queue for this UART. Returns <code>None</code> if …\nRetrieves the event queue for this UART. Returns <code>None</code> if …\nClears the receive buffer.\nWaits until the transmission is complete.\nClears the receive buffer.\nWaits for the transmission to complete.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSplit the serial driver in separate TX and RX drivers.\nConfigures the flags to use for interrupt allocation, e.g. …\nCreate a new serial driver\nCreate a new serial receiver\nCreate a new serial transmitter\nSafety\nSafety\nReturns the current type of parity checking\nReturns the current type of parity checking\nReturns the current type of parity checking\nNumber of events that should fit into the event queue. …\nRead multiple bytes into a slice\nRead multiple bytes into a slice; block until specified …\nGet count of remaining bytes in the receive ring buffer\nGet count of remaining capacity in the transmit ring buffer\nThe size of the software rx buffer. Must be bigger than …\nSplit the serial driver in separate TX and RX drivers\nSplit the serial driver in separate TX and RX drivers\nReturns the current number of stop bits\nReturns the current number of stop bits\nReturns the current number of stop bits\nThe size of the software tx buffer. Must be bigger than …\nWaits until the transmission is complete or until the …\nWaits until the transmission is complete or until the …\nWrite multiple bytes from a slice\nWrite multiple bytes from a slice\nWrite multiple bytes from a slice directly to the TX FIFO …\nWrite multiple bytes from a slice directly to the TX FIFO …\nThe number of bytes received\nWhether a timeout has occurred. It is possible that bytes …\nUART source clock from <code>APB</code>\nUART configuration\nUART source clock from <code>XTAL</code>\nNumber of data bits\nConfigures the interrupts the UART driver should enable in …\nNumber of data bits\nParity check\nUART source clock from <code>RTC</code>\n1 stop bit\n1.5 stop bits\n2 stop bits\nUART source clock\nNumber of stop bits\nConfigures the interrupts the driver should enable.\nOther interrupts to enable\nThis setting only has effect if flow control is enabled. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfigures the flags to use for interrupt allocation, e.g. …\nNumber of events that should fit into the event queue. …\nIf <code>Some(number_of_words)</code>, an interrupt will trigger after …\nSets the threshold at which an interrupt will be generated …\nThe size of the software rx buffer. Must be bigger than …\nSets the threshold <strong>below</strong> which an interrupt will be …\nThe size of the software tx buffer. Must be bigger than …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")